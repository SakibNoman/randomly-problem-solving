#include<iostream>
using namespace std;
class Timus
{
    public:
    void output();
};
void Timus::output()
{
    int n,sum;
    cin>>n;
    if(n>0)
      cout<<(n*(n+1))/2;
    else
    {
      n=n*-1;
      cout<<1-((n*(n+1))/2);
    }
      
}
int main()
{
    Timus m;
    m.output();
    return 0;
}
/*ǯছাটিট সবসময় ≤
√
n হেব। ǯকন? এিট direct ɔমাণ করা মেন হয় একটু কিঠন হেব, িকʞ Proof
by Contradiction িকʞ খুবই ǯসাজা। মেন কর ǯছাটিট √
n এর ǯথেকও বড়, তাহেল ঐ ǯজাড়ার
বড়টােতা বড় হেবই! আর ǯজাড়াʝিল এমনভােব বানােনা হেয়েছ ǯযন তােদর ʝনফল n হয়। িকʞ ʣইিট
√
n এর ǯথেক বড় সংখǫার ʝনফল ǯকমেন n হয়? অতএব ǯজাড়ার ǯছাটিটেক অবɹই √
n এর সমান
বা ǯছাট হেত হেব। এভােব আমরা যিদ ǯকাড কির (ǯকাড ৩.2) তাহেল আমােদর run time হেব
O
(√
n
)
. এখােন ǯখয়াল করেত পার ǯয আমরা আমােদর for loop এর condition টা i ∗ i ≤ n
িলেখিছ, i ≤ sqrt(n) না। এর িকছু কারণ আেছ। ɔথমত, বার বার sqrt িহসাব করা একিট costly
কাজ। িȻতীয়ত, double বǫবহার করেল িকʞ precision loss হয়। এর ফেল sqrt(9) = 3 না হেয়
2.9999999 বা 3.0000001 হেলও অবাক হবার িকছু ǯনই।১
িকʞ বার বার i∗i করাও ǯকমন জািন!
ǯতামরা যা করেত পার তাহল loop ʤʡ হবার আেগই limit = sqrt(n + 1) কের িনেত পার। এর
পর এই পযǮɂ loop চালােব। তাহেল বার বার sqrt ও করা লাগেব না ʝন ও করা লাগেব না।
আব্দুল্লাহ আল নোমান সাকিব।।
বিজিসি ট্রাস্ট ইউনিভার্সিটি বাংলাদেশ ।।*/